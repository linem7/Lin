% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute.R
\name{compute}
\alias{compute}
\title{Compute New Variables by Aggregating Multiple Columns}
\usage{
compute(.data, ...)
}
\arguments{
\item{.data}{A data frame or tibble containing the source variables}

\item{...}{Variable specifications followed by aggregation function and options:
\itemize{
  \item **Named variable specifications** using one of three methods:
    \itemize{
      \item \strong{Pattern + Index:} \code{var_name = "pattern{i}", indices}
            (e.g., \code{score1 = "item{i}", 1:5})
      \item \strong{Explicit Vector:} \code{var_name = c("var1", "var2", ...)}
            (e.g., \code{score2 = c("item1", "item3", "item5")})
      \item \strong{Variable Range (Position-Based):} \code{var_name = "start_var:end_var"}
            Selects all columns from start_var to end_var based on their positions
            in the data frame, regardless of naming patterns. Supports reverse order.
    }
  \item **Aggregation function** as unnamed argument (e.g., \code{mean}, \code{sum}, \code{median})
  \item **Optional \code{na.rm}** logical argument for handling missing values
}}
}
\value{
A data frame identical to \code{.data} with additional computed variables
  appended as new columns. Original columns remain unchanged.
}
\description{
Creates new variables by applying aggregation functions (mean, sum, etc.) to
multiple columns using flexible variable selection methods. Supports three
approaches: pattern-based indexing, explicit variable vectors, and variable ranges.
Designed to work seamlessly with dplyr pipelines.
}
\details{
**Variable Selection Methods:**

\strong{Pattern Method:} Uses a pattern string containing \code{{i}} placeholder
followed by numeric indices. The pattern \code{"item{i}"} with indices \code{1:5}
expands to \code{c("item1", "item2", "item3", "item4", "item5")}.

\strong{Explicit Vector Method:} Directly specify column names as a character vector.
Useful for non-sequential or custom variable selections.

\strong{Variable Range Method (Position-Based):} Use colon notation \code{"start:end"}
to select all columns between the positions of the start and end variables (inclusive).
The start and end variables do not need to share prefixes or follow any naming pattern.
Selection is based purely on column positions in the data frame. If start appears
after end, selection proceeds in reverse order.

**Performance Optimization:** For \code{mean} and \code{sum} functions with multiple
columns, the function uses optimized \code{rowMeans()} and \code{rowSums()}
implementations. Other functions use \code{apply()} row-wise computation.

**Error Handling:** Missing columns generate warnings but don't stop execution.
All selected columns must be numeric. If no valid columns are found for a
specification, the result variable is filled with \code{NA}.
}
\examples{
library(dplyr)

# Create sample data with mixed naming patterns
set.seed(123)
data <- data.frame(
  id = 1:100,
  item1 = rnorm(100, 3, 1),
  item2 = rnorm(100, 3, 1),
  height = rnorm(100, 170, 10),
  weight = rnorm(100, 70, 15),
  score_a = rnorm(100, 85, 10),
  score_b = rnorm(100, 88, 12),
  final_grade = rnorm(100, 90, 8),
  temperature = rnorm(100, 25, 5)
)

# Position-based range selection (NEW FUNCTIONALITY)
# Works regardless of naming patterns
data_ranges <- data \%>\%
  compute(
    physical_measures = "height:score_b",    # Columns 4-6: height, weight, score_a, score_b
    mixed_range = "item1:weight",           # Columns 2-4: item1, item2, height, weight
    end_range = "score_a:temperature",      # Columns 5-8: score_a, score_b, final_grade, temperature
    mean, na.rm = TRUE
  )

# Traditional pattern method still works
data_pattern <- data \%>\%
  compute(
    item_mean = "item{i}", 1:2,
    mean, na.rm = TRUE
  )

# Explicit vector method
data_explicit <- data \%>\%
  compute(
    custom_score = c("height", "final_grade", "temperature"),
    mean, na.rm = TRUE
  )

# Reverse order range selection
data_reverse <- data \%>\%
  compute(
    reverse_range = "temperature:score_a",  # Selects in reverse: temperature, final_grade, score_b, score_a
    mean, na.rm = TRUE
  )

}
