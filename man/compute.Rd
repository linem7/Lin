% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute.R
\name{compute}
\alias{compute}
\title{Compute New Variables by Aggregating Multiple Columns}
\usage{
compute(.data, ...)
}
\arguments{
\item{.data}{A data frame or tibble containing the source variables}

\item{...}{Variable specifications followed by aggregation function and options:
\itemize{
  \item **Named variable specifications** using one of three methods:
    \itemize{
      \item \strong{Pattern + Index:} \code{var_name = "pattern{i}", indices}
            (e.g., \code{score1 = "item{i}", 1:5})
      \item \strong{Explicit Vector:} \code{var_name = c("var1", "var2", ...)}
            (e.g., \code{score2 = c("item1", "item3", "item5")})
      \item \strong{Variable Range:} \code{var_name = "start_var:end_var"}
            (e.g., \code{score3 = "item1:item5"})
    }
  \item **Aggregation function** as unnamed argument (e.g., \code{mean}, \code{sum}, \code{median})
  \item **Optional \code{na.rm}** logical argument for handling missing values
}}
}
\value{
A data frame identical to \code{.data} with additional computed variables
  appended as new columns. Original columns remain unchanged.
}
\description{
Creates new variables by applying aggregation functions (mean, sum, etc.) to
multiple columns using flexible variable selection methods. Supports three
approaches: pattern-based indexing, explicit variable vectors, and variable ranges.
Designed to work seamlessly with dplyr pipelines.
}
\details{
**Variable Selection Methods:**

\strong{Pattern Method:} Uses a pattern string containing \code{{i}} placeholder
followed by numeric indices. The pattern \code{"item{i}"} with indices \code{1:5}
expands to \code{c("item1", "item2", "item3", "item4", "item5")}.

\strong{Explicit Vector Method:} Directly specify column names as a character vector.
Useful for non-sequential or custom variable selections.

\strong{Variable Range Method:} Use colon notation \code{"start:end"} for sequential
variables with the same prefix and numeric suffixes. Automatically handles
zero-padded formats (e.g., \code{"q01:q05"}).

**Performance Optimization:** For \code{mean} and \code{sum} functions with multiple
columns, the function uses optimized \code{rowMeans()} and \code{rowSums()}
implementations. Other functions use \code{apply()} row-wise computation.

**Error Handling:** Missing columns generate warnings but don't stop execution.
All selected columns must be numeric. If no valid columns are found for a
specification, the result variable is filled with \code{NA}.
}
\examples{
library(dplyr)

# Create sample data
set.seed(123)
data <- data.frame(
  id = 1:100,
  item1 = rnorm(100, 3, 1), item2 = rnorm(100, 3, 1), item3 = rnorm(100, 3, 1),
  item4 = rnorm(100, 3, 1), item5 = rnorm(100, 3, 1), item6 = rnorm(100, 4, 1),
  item7 = rnorm(100, 4, 1), item8 = rnorm(100, 4, 1), item9 = rnorm(100, 4, 1),
  item10 = rnorm(100, 4, 1), item11 = rnorm(100, 5, 1), item12 = rnorm(100, 5, 1),
  item13 = rnorm(100, 5, 1), item14 = rnorm(100, 5, 1), item15 = rnorm(100, 5, 1)
)

# Add missing values for testing
data[1:5, c("item1", "item6", "item11")] <- NA

# Method 1: Pattern + Index specification
data_means <- data \%>\%
  compute(
    scale1_mean = "item{i}", 1:5,
    scale2_mean = "item{i}", 6:10,
    scale3_mean = "item{i}", 11:15,
    mean, na.rm = TRUE
  )

# Method 2: Explicit variable vector
data_custom <- data \%>\%
  compute(
    custom_score = c("item1", "item3", "item5", "item7"),
    mean, na.rm = TRUE
  )

# Method 3: Variable range specification
data_ranges <- data \%>\%
  compute(
    early_items = "item1:item5",
    late_items = "item11:item15",
    mean, na.rm = TRUE
  )

# Mixed methods in single call
data_mixed <- data \%>\%
  compute(
    pattern_mean = "item{i}", 1:3,              # Pattern method
    explicit_mean = c("item4", "item6", "item8"), # Explicit method
    range_sum = "item10:item12",                 # Range method
    mean, na.rm = TRUE
  )

# Using different aggregation functions
data_sums <- data \%>\%
  compute(
    total1 = "item1:item5",
    total2 = c("item6", "item8", "item10"),
    sum, na.rm = FALSE
  )

# Other statistical functions
data_stats <- data \%>\%
  compute(
    median_score = "item1:item5",
    median, na.rm = TRUE
  ) \%>\%
  compute(
    sd_score = c("item6", "item7", "item8"),
    sd, na.rm = TRUE
  )

# Zero-padded variable names
padded_data <- data.frame(
  id = 1:50,
  q01 = rnorm(50), q02 = rnorm(50), q03 = rnorm(50),
  q04 = rnorm(50), q05 = rnorm(50)
)

padded_result <- padded_data \%>\%
  compute(
    questionnaire_mean = "q01:q05",
    mean, na.rm = TRUE
  )

# Non-sequential selections with pattern method
data_nonseq <- data \%>\%
  compute(
    odd_items = "item{i}", c(1, 3, 5, 7, 9),
    even_items = "item{i}", c(2, 4, 6, 8, 10),
    mean, na.rm = TRUE
  )

}
\seealso{
\code{\link[base]{mean}}, \code{\link[base]{sum}},
  \code{\link[base]{rowMeans}}, \code{\link[base]{rowSums}},
  \code{\link[dplyr]{mutate}}
}
