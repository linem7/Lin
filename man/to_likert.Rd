% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/to_likert.R
\name{to_likert}
\alias{to_likert}
\title{Convert continuous item scores to Likert-style numeric data at the construct level}
\usage{
to_likert(
  data,
  var_config,
  return_meta = FALSE,
  calibrate_iters = 3,
  calibrate_grid = 201,
  shift_range = c(-4, 4)
)
}
\arguments{
\item{data}{A `data.frame` containing continuous item variables.}

\item{var_config}{A non-empty list of configuration lists. Each element defines one construct:
\itemize{
  \item `vars` (character vector): column names of the construct's items.
  \item `n_levels` (integer): number of Likert levels (e.g., 5, 7, 9).
  \item `target_mean` (numeric): desired pooled mean of the construct after conversion,
        must be within \eqn{[1, n_levels]}.
  \item `shape` (numeric, optional): controls how concentrated the distribution is around
        the middle categories; smaller values yield stronger middle-concentration
        (default = 1.0).
  \item `construct` (character, optional): label used in the returned meta.
}}

\item{return_meta}{Logical. If `TRUE`, returns a list with `data` (converted dataset)
and `meta` (diagnostics and reusable thresholds). Default `FALSE`.}

\item{calibrate_iters}{Integer >= 1. Number of coarse-to-fine iterations used to search
for the threshold shift that best matches `target_mean`. Default `3`.}

\item{calibrate_grid}{Integer >= 11. Number of candidate shift values evaluated per
iteration. Larger values are more precise but slower. Default `201`.}

\item{shift_range}{Numeric vector of length 2, e.g. `c(-4, 4)`. Search range for the
global threshold shift on the standardized (z) scale. Default `c(-4, 4)`.}
}
\value{
If `return_meta = FALSE`, a `data.frame` with specified variables replaced by numeric Likert
scores \eqn{1..n_levels}. If `return_meta = TRUE`, a list:
\itemize{
  \item `data`: the converted `data.frame`
  \item `meta`: a list of per-construct diagnostics and reusable thresholds
}
}
\description{
`to_likert()` takes a continuous dataset (typically generated by `lavaan::simulateData()`)
and converts specified groups of variables (constructs) into Likert-style numeric scores
\eqn{1..n_levels}. The conversion is performed at the construct level: for each construct,
all its items share the same set of thresholds after calibration, so the construct's
pooled mean is targeted rather than each item's mean.

The output is numeric (not ordered factors) because the intended downstream workflow
treats Likert scores as continuous in SEM.
}
\details{
Workflow (per construct):
\enumerate{
  \item Pool all specified item values to compute a construct-level mean and SD.
        Each item is standardized using the pooled mean and SD:
        \eqn{Z_{ij} = (X_{ij} - \mu_{\text{pool}}) / \sigma_{\text{pool}}}.
  \item Build a symmetric "middle-heavy" category probability template determined by
        `shape`, then convert its cumulative probabilities into standard-normal cutpoints
        (base thresholds). This enforces the desired qualitative shape: middle categories
        are more frequent than extremes under a near-normal latent distribution.
  \item Calibrate a single scalar shift \eqn{s} by searching within `shift_range` so that
        the pooled mean of the discretized construct, \eqn{\bar{Y}(s)}, is as close as
        possible to `target_mean`.
  \item Apply the final thresholds \eqn{t_k + s} to every item in the construct and output
        numeric scores \eqn{1..n_levels}.
}

When the achieved mean does not match the target mean:
\itemize{
  \item If `meta[[i]]$shift` is near the boundary of `shift_range`, expand `shift_range`
        (e.g., from `c(-4, 4)` to `c(-8, 8)`), especially for very high/low target means.
  \item If `shift` is not near a boundary but the achieved mean is still off, increase
        `calibrate_grid` (e.g., 201 -> 401) or `calibrate_iters` (e.g., 3 -> 4).
  \item If category frequencies are too concentrated in the middle (or too spread out),
        adjust `shape`:
        \itemize{
          \item smaller `shape` -> more middle-heavy, fewer extremes
          \item larger `shape`  -> less middle-heavy, more spread to extremes
        }
  \item If the pooled SD of the construct is ~0 (near-constant items), conversion cannot
        meaningfully shape the distribution; the function will output a constant value
        (rounded `target_mean`) for non-missing observations.
}

Interpretation of key meta fields (when `return_meta=TRUE`):
\itemize{
  \item `achieved_mean_pooled`: pooled mean across all converted items in the construct.
  \item `shift`: the calibrated scalar added to all base thresholds to hit `target_mean`.
  \item `thresholds`: final cutpoints used for conversion; can be reused for strict
        reproducibility across runs or datasets.
  \item `mu_pool`, `sd_pool`: pooled mean and SD used for construct-level standardization.
}
}
\examples{
library(lavaan)

## Example 1: Two constructs, 5-point scoring, different target means
set.seed(123)
model <- '
  fA =~ 0.8*a1 + 0.7*a2 + 0.9*a3 + 0.75*a4 + 0.85*a5
  fB =~ 0.8*b1 + 0.7*b2 + 0.9*b3 + 0.75*b4 + 0.85*b5
  fA ~~ 0.3*fB
'
cont <- simulateData(model, sample.nobs = 3000)

cfg <- list(
  list(construct = "A", vars = paste0("a", 1:5), n_levels = 5, target_mean = 3.6, shape = 1.0),
  list(construct = "B", vars = paste0("b", 1:5), n_levels = 5, target_mean = 2.3, shape = 1.0)
)

res <- to_likert(cont, cfg, return_meta = TRUE)
dat_lik <- res$data

res$meta[[1]]$achieved_mean_pooled
res$meta[[2]]$achieved_mean_pooled

table(unlist(dat_lik[paste0("a", 1:5)]))
prop.table(table(unlist(dat_lik[paste0("a", 1:5)])))

table(unlist(dat_lik[paste0("b", 1:5)]))
prop.table(table(unlist(dat_lik[paste0("b", 1:5)])))

## Example 2: Higher n_levels and a simple timing check
set.seed(456)
model2 <- '
  fA =~ 0.8*a1 + 0.8*a2 + 0.8*a3 + 0.8*a4 + 0.8*a5 + 0.8*a6 + 0.8*a7 + 0.8*a8
  fB =~ 0.8*b1 + 0.8*b2 + 0.8*b3 + 0.8*b4 + 0.8*b5 + 0.8*b6 + 0.8*b7 + 0.8*b8
  fA ~~ 0.3*fB
'
cont2 <- simulateData(model2, sample.nobs = 20000)

cfg2 <- list(
  list(construct = "A", vars = paste0("a", 1:8), n_levels = 7, target_mean = 5.2, shape = 1.1),
  list(construct = "B", vars = paste0("b", 1:8), n_levels = 7, target_mean = 3.1, shape = 1.1)
)

t <- system.time({
  res2 <- to_likert(cont2, cfg2, return_meta = TRUE,
                   calibrate_iters = 3, calibrate_grid = 201, shift_range = c(-4, 4))
})
t
res2$meta[[1]]$achieved_mean_pooled
res2$meta[[2]]$achieved_mean_pooled

}
