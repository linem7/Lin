% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/likertize_zscore.R
\name{likertize_zscore}
\alias{likertize_zscore}
\title{Convert Z-scores to a Likert scale (with optional skew)}
\usage{
likertize_zscore(z_score, n_levels = 5, skew = 0)
}
\arguments{
\item{z_score}{Numeric vector of (approximately) standard normal values to be discretized.
Missing values are preserved.}

\item{n_levels}{Integer (>= 2). Number of Likert categories to create. Defaults to 5.}

\item{skew}{Numeric, controls asymmetry of the **target** density used to set the cuts.
Use \code{0} for symmetric normal (default). Nonzero values induce skewness via the
skew-normal family. This argument is transformed to a skew-normal \code{alpha}
(shape) by \eqn{ \alpha = \frac{\text{skew}}{\sqrt{1-\text{skew}^2}} \sqrt{2/\pi} }.
Reasonable range is \code{-0.95} to \code{0.95}. Extreme values may be unstable.}
}
\value{
An integer vector with values in \code{1:n_levels}. If \code{as.ordered} behavior
  is desired, convert the result to \code{ordered()} outside this function.
}
\description{
Discretizes continuous Z-scores into \eqn{1..n\_levels} Likert categories so that
the **marginal category proportions** follow either:
(a) the standard normal density (when `skew = 0`), or
(b) a univariate skew-normal density (when `skew != 0`).
}
\details{
Internally, this function uses a helper \code{discretize_density()} to compute
\emph{endpoints} that partition the real line into \code{n_levels} bins whose
areas (probabilities) match the target density. It then cuts the input \code{z_score}
at those endpoints and relabels the bins as integer Likert levels.


- This function **does not** re-estimate any density from the data. It only uses the
  chosen reference density (normal or skew-normal) to define **proportionally balanced
  cutpoints** and then bins the provided \code{z_score}.
- The helper \code{discretize_density(density_fn, n_levels, eps)} must exist in your
  environment (usually elsewhere in the same package). It is expected to return a list
  with a numeric vector \code{endp} of length \code{n_levels + 1}, i.e., the cumulative
  probability endpoints (on the Z-scale) that define the category boundaries.
}
\examples{
# Basic: 5-point Likert with symmetric category proportions
set.seed(1)
z <- rnorm(1000)
x5 <- likertize_zscore(z, n_levels = 5)
table(x5) / length(x5)  # ~balanced under normal reference

# Skewed category proportions (right-skew in the reference density)
x5_skew <- likertize_zscore(z, n_levels = 5, skew = 0.5)
table(x5_skew) / length(x5_skew)

# 7-point scale
x7 <- likertize_zscore(z, n_levels = 7)
head(x7)

}
\seealso{
discretize_density
}
