#' Create a Model Fit Table from MplusAutomation Output
#'
#' This function extracts the summary statistics from one or more Mplus models generated
#' by the \code{MplusAutomation} package and creates a table of fit indices.
#' The function supports both single model objects and lists of models. In the case of
#' mixed input (e.g. a single model object plus a list of models), the input is flattened
#' so that each model's summary is processed.
#'
#' For model comparison, the function computes chi-square differences using:
#' \itemize{
#'   \item For \code{"ML"} models: a simple difference in chi-square values and degrees of freedom.
#'   \item For \code{"MLR"}, \code{"MLM"}, or \code{"WLSM"} models: a log-likelihood based chi-square
#'         difference test with a scaling correction factor.
#' }
#'
#' @param ... One or more model objects or lists of models generated by \code{readModels} in MplusAutomation.
#' @param indices A character vector of indices to be reported. Default is
#'   \code{c("Filename", "ChiSqM_Value", "ChiSqM_DF", "CFI", "TLI", "RMSEA_Estimate", "SRMR")}.
#' @param ref Character string indicating the reference model for comparison. Either
#'   \code{"last"} (default; compare to the previous model) or \code{"first"}.
#' @param diffTest Logical. If \code{TRUE} (default), the function includes difference metrics
#'   (changes in CFI, TLI, RMSEA, and chi-square difference).
#' @param digits Integer specifying the number of digits for reporting the indices (except df, which is always an integer).
#'
#' @return A \code{data.table} (data.frame) with the selected fit indices and, if requested,
#'   the computed difference metrics.
#'
#' @details
#' The function flattens input arguments so that if a provided argument is a list of models
#' (with class \code{"mplus.model.list"}), each model is extracted and processed. It validates
#' that every model contains a \code{"summaries"} element. The chi-square difference is computed
#' either by simple subtraction (for \code{"ML"} models) or by a log-likelihood based test (for
#' \code{"MLR"}, \code{"MLM"}, or \code{"WLSM"} models) provided that the necessary columns are available.
#'
#' @examples
#' \dontrun{
#'   # Example with a single model object:
#'   fit_table(models$model1)
#'
#'   # Example with a list of models:
#'   fit_table(list(models$model1, models$model2))
#'
#'   # Example with mixed inputs (single model and a list of models):
#'   fit_table(models_saturated$apim_step1.1_saturated.out, models_actor_partner)
#' }
#'
#' @export
fit_table <- function(...,
                      indices = c("Filename", "ChiSqM_Value", "ChiSqM_DF",
                                  "CFI", "TLI", "RMSEA_Estimate", "SRMR"),
                      ref = c("last", "first"),
                      diffTest = TRUE,
                      digits = 3) {
  ref <- match.arg(ref)

  # Flatten input so that if an argument is a list of models (without a "summaries" element),
  # then each model is extracted and appended to the main list.
  args <- list(...)
  modelList <- list()
  for (obj in args) {
    if (is.list(obj) && !("summaries" %in% names(obj))) {
      # Assume obj is a list of models; extract each model.
      for (m in obj) {
        if (!("summaries" %in% names(m))) {
          stop("One of the models in a provided list does not contain a 'summaries' element.")
        }
        modelList[[length(modelList) + 1]] <- m
      }
    } else if (is.list(obj) && ("summaries" %in% names(obj))) {
      modelList[[length(modelList) + 1]] <- obj
    } else {
      stop("Input is not a valid model object or list of models.")
    }
  }

  # Validate that every model has a "summaries" element.
  for (i in seq_along(modelList)) {
    if (!("summaries" %in% names(modelList[[i]]))) {
      stop(sprintf("Model %d does not contain a 'summaries' element.", i))
    }
  }

  # Extract the summaries from each model.
  summaries_list <- lapply(modelList, function(model) as.data.frame(model[["summaries"]]))

  # Combine summaries into one data frame.
  combined_table <- do.call(rbind, summaries_list)

  # Warn if some of the requested indices are missing.
  missing_cols <- setdiff(indices, names(combined_table))
  if (length(missing_cols) > 0) {
    warning(sprintf("The following indices are missing from the model summaries: %s",
                    paste(missing_cols, collapse = ", ")))
  }

  # Convert key columns to numeric.
  if ("CFI" %in% names(combined_table))
    combined_table$CFI <- as.numeric(as.character(combined_table$CFI))
  if ("TLI" %in% names(combined_table))
    combined_table$TLI <- as.numeric(as.character(combined_table$TLI))
  if ("RMSEA_Estimate" %in% names(combined_table))
    combined_table$RMSEA_Estimate <- as.numeric(as.character(combined_table$RMSEA_Estimate))
  if ("ChiSqM_Value" %in% names(combined_table))
    combined_table$ChiSqM_Value <- as.numeric(as.character(combined_table$ChiSqM_Value))
  if ("ChiSqM_DF" %in% names(combined_table))
    combined_table$ChiSqM_DF <- as.numeric(as.character(combined_table$ChiSqM_DF))
  if ("LL" %in% names(combined_table))
    combined_table$LL <- as.numeric(as.character(combined_table$LL))
  if ("Parameters" %in% names(combined_table))
    combined_table$Parameters <- as.numeric(as.character(combined_table$Parameters))

  n <- nrow(combined_table)

  # Initialize vectors for difference columns.
  diff_CFI   <- rep(NA, n)
  diff_TLI   <- rep(NA, n)
  diff_RMSEA <- rep(NA, n)
  chisq_diff <- rep("", n)   # Concatenated chi-square difference (value, df, significance stars)
  chisq_p    <- rep("", n)   # Chi-square difference p-value

  # Compute the difference metrics if requested.
  if (diffTest && n > 0) {
    for (i in 1:n) {
      # Determine the reference row based on the 'ref' argument.
      if (ref == "first") {
        ref_row <- if (i == 1) NA else 1
      } else if (ref == "last") {
        ref_row <- if (i == 1) NA else i - 1
      }

      if (is.na(ref_row)) {
        diff_CFI[i]   <- NA
        diff_TLI[i]   <- NA
        diff_RMSEA[i] <- NA
        chisq_diff[i] <- ""
        chisq_p[i]    <- ""
      } else {
        # Compute differences for CFI, TLI, and RMSEA.
        if ("CFI" %in% names(combined_table))
          diff_CFI[i] <- combined_table$CFI[i] - combined_table$CFI[ref_row]
        if ("TLI" %in% names(combined_table))
          diff_TLI[i] <- combined_table$TLI[i] - combined_table$TLI[ref_row]
        if ("RMSEA_Estimate" %in% names(combined_table))
          diff_RMSEA[i] <- combined_table$RMSEA_Estimate[i] - combined_table$RMSEA_Estimate[ref_row]

        # Simplified chi-square difference computation.
        if (!is.na(combined_table$Estimator[i]) && !is.na(combined_table$Estimator[ref_row]) &&
            combined_table$Estimator[i] == combined_table$Estimator[ref_row]) {
          est <- combined_table$Estimator[i]
          if (est == "ML") {
            # For ML, use the normal chi-square test.
            delta_chisq <- combined_table$ChiSqM_Value[i] - combined_table$ChiSqM_Value[ref_row]
            delta_df    <- combined_table$ChiSqM_DF[i] - combined_table$ChiSqM_DF[ref_row]
          } else if (est %in% c("MLR", "MLM", "WLSM")) {
            # For MLR, MLM, and WLSM, use log-likelihood based chi-square difference with scaling correction.
            if (all(c("LL", "LLCorrectionFactor", "Parameters") %in% names(combined_table))) {
              # Determine the nested ordering based on the number of parameters.
              if (combined_table$Parameters[i] > combined_table$Parameters[ref_row]) {
                H0_index <- ref_row
                H1_index <- i
              } else {
                H0_index <- i
                H1_index <- ref_row
              }
              cd <- (combined_table$Parameters[H0_index] * combined_table$LLCorrectionFactor[H0_index] -
                       combined_table$Parameters[H1_index] * combined_table$LLCorrectionFactor[H1_index]) /
                (combined_table$Parameters[H0_index] - combined_table$Parameters[H1_index])
              delta_chisq <- -2 * (combined_table$LL[H0_index] - combined_table$LL[H1_index]) / cd
              delta_df <- combined_table$Parameters[H1_index] - combined_table$Parameters[H0_index]
            } else {
              delta_chisq <- NA
              delta_df <- NA
            }
          } else {
            delta_chisq <- NA
            delta_df <- NA
          }
          p_val <- if (!is.na(delta_df) && delta_df > 0) 1 - pchisq(delta_chisq, df = delta_df) else NA
        } else {
          # Set to NA if estimator information is missing or models use different estimators.
          delta_chisq <- NA
          delta_df <- NA
          p_val <- NA
        }

        stars <- ""
        if (!is.na(p_val)) {
          if (p_val < 0.001) stars <- "***"
          else if (p_val < 0.01) stars <- "**"
          else if (p_val < 0.05) stars <- "*"
          else if (p_val < 0.1) stars <- "."
        }

        chisq_diff[i] <- if (!is.na(delta_chisq) && !is.na(delta_df))
          sprintf(paste0("%.", digits, "f (%d) %s"), delta_chisq, as.integer(delta_df), stars)
        else ""
        chisq_p[i] <- if (!is.na(p_val)) sprintf(paste0("%.", digits, "f"), p_val) else ""
      }
    }
  }

  # Subset the final table to the requested indices.
  final_table <- combined_table[, intersect(indices, names(combined_table)), drop = FALSE]

  # Append difference metrics if diffTest is TRUE.
  if (diffTest) {
    final_table$diff_CFI   <- if ("CFI" %in% names(combined_table)) sprintf(paste0("%.", digits, "f"), diff_CFI) else NA
    final_table$diff_TLI   <- if ("TLI" %in% names(combined_table)) sprintf(paste0("%.", digits, "f"), diff_TLI) else NA
    final_table$diff_RMSEA <- if ("RMSEA_Estimate" %in% names(combined_table)) sprintf(paste0("%.", digits, "f"), diff_RMSEA) else NA
    final_table$chisq_diff <- chisq_diff
    final_table$chisq_p    <- chisq_p
  }

  # Format numeric columns (except for ChiSqM_DF) to the specified number of digits.
  num_cols <- sapply(final_table, is.numeric)
  for (col in names(final_table)[num_cols]) {
    if (col != "ChiSqM_DF") {
      final_table[[col]] <- sprintf(paste0("%.", digits, "f"), final_table[[col]])
    }
  }

  # Remove row names.
  rownames(final_table) <- NULL

  # Rename columns for clarity.
  colnames(final_table)[colnames(final_table) == "Filename"] <- "Models"
  colnames(final_table)[colnames(final_table) == "ChiSqM_Value"] <- "Chisq"
  colnames(final_table)[colnames(final_table) == "ChiSqM_DF"]    <- "df"
  colnames(final_table)[colnames(final_table) == "RMSEA_Estimate"]<- "RMSEA"

  return(final_table)
}
